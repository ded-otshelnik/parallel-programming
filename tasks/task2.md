# Задача 2. Указатели, массивы, строки

## Требования

+ Комментарии на английском к коду обязательны (!), функции должны быть задокументированы.
+ Массивы (чисел или строк) должны инициализироваться либо из файла, либо случайным образом. Ввод значений массива с stdin запрещен.
+ Любые параметры программы должны вводиться через командную строку с последующей их валидацией. В случае правильного результата вывести "help"-строку (описание программы и параметров, которые принимает) и вернуть 1 (EXIT_FAILURE).

## Варианты

1. Реализовать алгоритм бинарного поиска в целочисленном массиве.
2. Реализовать алгоритм поиска медианы в целочисленном массиве.
3. Реализовать алгоритм поиска моды в целочисленном массиве. Если таких чисел несколько, вывести все.
4. Реализовать программу, которая объединяет два неотсортированных массива в один отсортированный.
5. Прямая на плоскости может быть задана уравнением $ax + by + c = 0$, где $a, b \neq 0$, $a, b, c \in Z$. Пусть даны коэффициенты нескольких прямых $a_1, b_1, c_1, a_2, b_2, c_2, ..., a_n, b_n, c_n$. Реализовать программу, которая определяет, имеются ли среди этих прямых совпадающие, пересекающиеся и параллельные.
6. Реализовать программу, которая смещает элементы массива на *k* единиц влево (если получится индекс, который больше длины, поместить в начало на соответствующее место).
7. Реализовать программу, которая выводит все локальные максимумы/минимумы (элемент больше/меньше соседей) в массиве.
8. Реализовать программу, которая собирает все четные элементы в одной части целочисленного массива, а все нечетные элементы - в другой.
9. Реализовать программу, проверяющая, образуют ли элементы целочисленного массива размера *N* геометрическую прогрессию. Если образует, то вывести знаменатель прогрессии, если нет — вывести *0*.
10. Дан массив $a_1,...,a_n$. Требуется посчитать количество различных непустых подпоследовательностей массива, где все элементы различны. Две подпоследовательности различны, если существует индекс, присутствующий в первой подпоследовательности и отсутствующий во второй.
11. Даны два массива $a_1,...,a_n$ и $b_1,...,b_m$, предварительно отсортированных. Реализовать программу, которая объединяет их в один отсортированный массив. Сортировку реализовать отдельно любым методом, данные инициализировать случайно.
12. Реализовать программу, которая находит в массиве размерности *N* все уникальные пары чисел, сумма которых равна заданному числу *S*.
13. Реализовать программу, которая ищет в массиве *k*-ю статистику. Алгоритмическая сложность не должна быть больше *O(N)*.
14. Дан отсортированный массив $a_1,...,a_n$, в котором все элементы уникальны. Реализовать программу, которая выводит диапазоны чисел, которые покрывают все значения массива. Например, [0,1,2,4,5,7] $\rightarrow$ ["0->2","4->5","7"], [0,2,3,4,6,8,9] $\rightarrow$ ["0","2->4","6","8->9"].
15. Общее значение XOR для массива определяется как побитовая операция XOR для всех элементов массива. Например, для массива [1, 3] XOR сумма будет равна 1 XOR 3 = 2, или 0 в случае пустого массива. Для некоторого массива найти сумму всех общих значений XOR для каждого подмассива исходного набора. Например, для массива [1, 3]: [] $\rightarrow$ 0, [1] $\rightarrow$ 1, [3] $\rightarrow$ 3, [1, 3] $\rightarrow$ 2, сумма - 6.
16. Реализовать программу, которая удаляет дупликаты из неотсортированного массива in-place (без создания нового массива, модифицируя исходный массив).
17. Реализовать программу, которая переводит строку-запись римского числа в десятичное и наоборот (например, XII -> 12 -> XII).
18. Реализовать функцию ```atof```, преобразующую строку в *double*. Сравнить с функцией из ```<stdlib.h>```.
19. Реализовать функцию ```atoi```, преобразующую строку в *int*. Сравнить с функцией из ```<stdlib.h>```.
20. Реализовать функцию ```atol```, преобразующую строку в *long*. Сравнить с функцией из ```<stdlib.h>```.
21. Напишите программу ```expr```, которая принимает из командной строки аргументы и вычисляет арифметическое выражение: например, ```expr 1 + 1``` должен вывести 2.
22. Напишите программу, которая сортирует массив аргументов командной строки и выводит в консоль.
23. Реализовать функцию ```strtok```, которая делит произвольную строку на токены (строки, разделенные символами-разделителями). Сравнить с функцией из ```<string.h>```.
24. Реализовать функцию ```strchr```, которая ищет первое вхождение символа *ch* в строке. Сравнить с функцией из ```<string.h>```.
25. Реализовать программу проверки строки на палиндром ("and DNA" - палиндром, "banana" - нет).
26. Реализовать программу инверсии каждого набора символов строки, отделенного пробелом.
27. Реализовать программу, проверяющую являются ли две строки анаграммой ("listen" и "silent" - анаграммы, "hello" и "lower" - нет).
28. Реализовать программу, которая считает количество вхождений некоторого набора символов в строку.
29. "Make The String Great Again": реализовать программу, удаляющую все буквы из строки, которые соседствуют и являются одинаковыми без учета регистра, причем удаление происходит до тех пор, пока это возможно. Например, "abbaca" $\rightarrow$ "aaca" $\rightarrow$ "ca", "azxxzy" $\rightarrow$ "azzy" $\rightarrow$ "ay".
30. Реализовать программу, которая проверяет правильность поставленных скобок ('(' и ')') в выражении.
31. Реализовать программу, которая принимает массив строк и находит самый длинный префикс, общий для всех строк. Например, ["flower","flow","flight"] $\rightarrow$ "fl", ["dog","racecar","car"] $\rightarrow$ "".
32. В некоторой файловой системе путь к файлу может выглядеть так: "/home/", "/a/./b/../../c/". Реализовать программу, которая упрощает такие пути ("/home/" $\rightarrow$ "/home", "/a/./b/../../c/" $\rightarrow$ "/c").
33. "Козья латынь": реализовать программу, которая переводит строку в "козий латинский": если слово начинается с гласной буквы, к слову добавляется "ma"; если первая буква согласная, то первая буква становится последней (перед "ma" или "а"); количество "a", добавляемых в конец, соответствует порядковому номеру слова. Например, "I speak Goat Latin" $\rightarrow$ "Imaa peaksmaaa oatGmaaaa atinLmaaaaa".
