# Задача 3. Структуры, управление памятью, заголовочные файлы

## Требования

+ Все задачи требуется реализовать, используя кастомные заголовочные файлы и разделяя функции по отдельным файлам.
+ Комментарии на английском к коду обязательны (!).
+ Все задачи, где применяются массивы, должны быть реализованы с использованием функций управления памятью (если возможно).
+ Если используется аргументы из командной строки, то реализовать проверку ввода.

## Варианты

1. Дана структура *date* и перечисление *day_of_week*:

    ```c
    struct date{
        unsigned short day, month, year;
    }
    enum DayOfWeek {Mo = 1, Tu, We, Th, Fr, Sa, Su};
    ```

    Реализовать:
    + функцию вычисляющую количество дней в месяце, к которому принадлежит дата *d*;
    + логическую функцию, проверяющую правильность даты *d*;
    + функцию, которая проверяет, сколько прошло дней от 1 января 1970 года до даты *d*.

2. Дана структура, описывающая комплексное число *z* (пара вещественных чисел). Реализовать программу-калькулятор (```+,-,*,/,pow(z, n)```) для работы с ними.
3. Дана структура, описывающая стек (размер стека ограничен числом *N*):

   ```c
    struct stack{
        int* data;
        int top;
    };
    ```

    Реализовать функции:
    + Проверки стека на пустоту/переполнение;
    + Добавления/удаления элемента из очереди;
    + Получения элемента на вершине стека без его удаления.

4. Дана структура, описывающая узел односвязного списка:

    ```c
    struct list_node{
        int value
        struct list_node *next;
    }
    ```

    Реализовать функции:
    + Преобразования массива целых чисел в односвязный список и обратно;
    + Добавления/удаления элемента списка по конкретному индексу;
  
5. Дана структура, описывающая узел сбалансированного бинарного дерева поиска:

    ```c
    struct tree_node{
        int value;
        struct tree_node *left;
        struct tree_node *right;
    }
    ```

    Реализовать функции:
    + Преобразования **отсортированного** целочисленного массива в бинарное дерево поиска.
    + Поиска в бинарном дереве поиска числа.

6. Даны два текстовых файла. Реализовать программу ```cat```, которая конкатенирует содержимое файлов и выводит полученное на экран или в другой файл.
7. Дан текстовый файл. Реализовать программу, подсчитывающую количество слов в тексте и количество букв английского алфавита, пробелов, знаков препинания.
8. Дан текстовый файл. Реализовать программу ```grep```, которая получает из командной строки список паттернов (для простоты, слов или последовательности букв) и файл и выводит вхождения в формате *"Line <номер строки>: <строка>"* и количество вхождений каждого паттерна в текст.
9. Дан текстовый файл. Реализовать программу ```caesar```, которая шифрует текст и записывает его в новый файл по следующему правилу: каждая буква в тексте смещается циклически на *n* позиций в алфавите (если *n*=3, то 'a' -> 'd', 'b' -> 'e', и т.д.) с таким же регистром. Предусмотреть возможность дешифровки полученного текста.
10. Дан файл с произвольным массивом чисел. Реализовать программу, которая отображает моду, медиану, размах массива (max - min), а также мат.ожидание и дисперсию для массива как выборки и записывает полученные результаты в файл.
11. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Гаусса.
12. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Крамера.
13. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Гаусса-Зейделя.
14. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом обратной матрицы.
15. Дана квадратная матрица A размерности $(n, n)$. Реализовать программу, которая реализует LU-разложение матрицы.
