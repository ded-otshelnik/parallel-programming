# Задача 3. Структуры, управление памятью, заголовочные файлы

## Требования

+ Комментарии на английском к коду обязательны (!), функции должны быть задокументированы.
+ Все задачи требуется реализовать, используя кастомные заголовочные файлы и разделяя функции по отдельным файлам.
+ Все задачи, где применяются массивы или структуры данных должны быть реализованы с использованием функций управления памятью.
+ Массивы и структуры данных должны инициализироваться либо из файла, либо случайным образом. Ввод значений массива с stdin запрещен.
+ Любые параметры программы должны вводиться через командную строку с последующей их валидацией. В случае правильного результата вывести "help"-строку (описание программы и параметров, которые принимает) и вернуть 1 (EXIT_FAILURE).

## Варианты

1. Дана структура *date* и перечисление *day_of_week*:

    ```c
    struct date{
        unsigned short day, month, year;
    }
    enum DayOfWeek {Mo = 1, Tu, We, Th, Fr, Sa, Su};
    ```

    Реализовать:
    + функцию вычисляющую количество дней в месяце, к которому принадлежит дата *d*;
    + логическую функцию, проверяющую правильность даты *d*;
    + функцию, которая возвращает день недели для даты *d* (1 - понедельник, 7 - воскресенье);
    + функцию, которая проверяет, сколько прошло дней от 1 января 1970 года (дата, от которой ведется отсчет в UNIX) до даты *d*.
    + функцию, которая возвращает строковое представление даты *d* в некотором формате (например, "01 January 1970", "01.01.1970", "January 1, 1970" и т.д.);

2. Дана структура, описывающая комплексное число *z* (пара вещественных чисел). Реализовать программу-калькулятор (```+,-,*,/,pow(z, n),sqrt(z)```) для работы с ними.
3. Дана структура, описывающая **стек** (размер стека ограничен числом *N*):

   ```c
    struct stack{
        int* data;
        int top;
    };
    ```

    Реализовать функции:
    + Проверки стека на пустоту/переполнение;
    + Добавления/удаления элемента из очереди;
    + Получения элемента на вершине стека без его удаления.

4. Дана структура, описывающая **стек** (размер стека ограничен числом *N*):

   ```c
    struct stack{
        int* data;
        int top;
    };
    ```

    Реализовать **очередь на основе двух стеков**, имплементировав также функции:
    + Проверки очереди на пустоту/переполнение;
    + Добавления/удаления элемента из очереди;
    + Получения элемента в начале очереди без его удаления и с удалением.

5. Дана структура, описывающая **очередь** (размер очереди ограничен числом *N*):

    ```c
    struct queue{
        int* data;
        int front, rear;
    };
    ```

    Реализовать **стек на основе двух очередей**, имплементировав также функции:
    + Проверки стека на пустоту/переполнение;
    + Добавления/удаления элемента из стека;
    + Получения элемента на вершине стека без его удаления и с удалением.

6. Дана структура, описывающая **узел односвязного списка**:

    ```c
    struct list_node{
        int value;
        struct list_node *next;
    }
    ```

    Реализовать функции:
    + Преобразования массива целых чисел в односвязный список и обратно;
    + Поиска элемента по значению в списке (возвращает индекс элемента или -1, если элемент не найден);
    + Добавления/удаления элемента списка по конкретному индексу.
  
7. Дана структура, описывающая **узел односвязного списка**:

    ```c
    struct list_node{
        int value;
        struct list_node *next;
    }
    ```

    Реализовать функции:
    + Реверса односвязного списка;
    + Проверки списка на наличие цикла в списке;
    + Сортировки списка.

8. Дана структура, описывающая **узел двусвязного списка**:

    ```c
    struct list_node{
        int value;
        struct list_node *next;
        struct list_node *prev;
    }
    ```

    Реализовать функции:
    + Реверса двусвязного списка;
    + Проверки списка на наличие цикла в списке;
    + Удаления всех элементов с заданным значением из списка.

9. Дана структура, описывающая **узел бинарного дерева**:

    ```c
    struct tree_node{
        int value;
        struct tree_node *left;
        struct tree_node *right;
    }
    ```

    Реализовать функции:
    + Преобразования **отсортированного** целочисленного массива в сбалансированное бинарное дерево.
    + Поиска числа в сбалансированном бинарном дереве.

10. Дана структура, описывающая **узел бинарного дерева**:

    ```c
    struct tree_node{
        int value;
        struct tree_node *left;
        struct tree_node *right;
    }
    ```

    Реализовать функции:
    + Поиска в глубину бинарного дерева (Depth-First Search).
    + Поиска в ширину бинарного дерева (Breadth-First Search).
    + Определения высоты бинарного дерева.

11. Дана структура, описывающая **узел бинарного дерева**:

    ```c
    struct tree_node{
        int value;
        struct tree_node *left;
        struct tree_node *right;
    }
    ```

    Реализовать функции:
    + Поиска минимальной разницы между значениями любых двух узлов в бинарном дереве.
    + Проверки, является ли бинарное дерево деревом поиска (Binary Search Tree).

12. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать функции:
    + Поиска в глубину графа (Depth-First Search).
    + Поиска в ширину графа (Breadth-First Search).
    + Определения наличия цикла в графе.

13. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа ко всем остальным.

14. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Пусть граф является звездообразным (все вершины связаны с центральной). Реализовать алгоритм поиска центра звезды.

15. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать алгоритм, который проверяет существует ли некоторый путь из одной вершины графа в другую. Если таких путей несколько, вывести наиболее длинный.

16. Реализовать структуру данных **хэш-множество (hash set)** и следующие функции:

       + Вставки элемента.
       + Поиска элемента.
       + Удаления элемента.

    Хэш-функция может быть реализована любым доступным способом (например, метод деления или метод умножения). В качестве типа элемента использовать целое число.

17. Реализовать структуру данных **хэш-таблица (hash map)** и следующие функции:

       + Вставки элемента.
       + Поиска элемента.
       + Удаления элемента.

    Хэш-функция может быть реализована любым доступным способом (например, метод деления или метод умножения). В качестве ключа использовать строку, в качестве значения - целое число.

18. Реализовать вычисление *n*-го числа Фибоначчи с помощью рекурсивной функции и **кэширования на основе hash map**. Протестировать на больших числах (например, 1000 и больше).
19. Даны два текстовых файла. Реализовать программу ```cat```, которая конкатенирует содержимое файлов и выводит полученное на экран или в другой файл.
20. Дан текстовый файл. Реализовать программу, подсчитывающую количество слов в тексте и количество букв английского алфавита, пробелов, знаков препинания.
21. Дан текстовый файл. Реализовать программу ```grep```, которая получает из командной строки список паттернов (для простоты, слов или последовательности букв) и файл и выводит вхождения в формате *"Line <номер строки>: <строка>"* и количество вхождений каждого паттерна в текст.
22. Дан текстовый файл. Реализовать программу ```caesar```, которая шифрует текст и записывает его в новый файл по следующему правилу: каждая буква в тексте смещается циклически на *n* позиций в алфавите (если *n*=3, то 'a' -> 'd', 'b' -> 'e', и т.д.) с таким же регистром. Предусмотреть возможность дешифровки полученного текста.
23. Дан файл с произвольным массивом чисел. Реализовать программу, которая отображает моду, медиану, размах массива (max - min), а также мат.ожидание и дисперсию для массива как выборки и записывает полученные результаты в файл.
24. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Гаусса.
25. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Крамера.
26. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом Гаусса-Зейделя.
27. Даны квадратная матрица A размерности $(n, n)$ и вектор-столбец B размерности $(n, 1)$ такие, что $Ax = B$. Реализовать программу для нахождения корней СЛАУ методом обратной матрицы.
28. Дана квадратная матрица A размерности $(n, n)$. Реализовать программу, которая реализует LU-разложение матрицы.
29. Дана квадратная матрица A размерности $(n, n)$. Реализовать программу, которая реализует QR-разложение матрицы.
