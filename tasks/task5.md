# Задание 5. OpenMP и управление общими ресурсами

## Требования

+ Варианты 1-5 подразумевают наличие некоторой тестовой программы, которая показывает возможности кода, работающая в течение определенного времени (например, 1 минута). Вариант 6-10 подразумевают наличие параллельной и последовательной реализации и измерение времени части кода, которая параллелится.
+ Комментарии на английском к коду обязательны, функции должны быть задокументированы.
+ Время* выполнения последовательной и параллельной версий должно быть записано и выведено на stdout или stderr.
+ Для проверки корректности работы запустить программу на 2, 4, 8, 16 потоках, причем количество потоков не должно устанавливаться программно.
+ Все задачи требуется реализовать, используя кастомные заголовочные файлы и разделяя функции по отдельным файлам. Сборка должна осуществляться с помощью Makefile или СMakeLists.txt. Реализация задания из варианта должна подключаться к основной программе либо как библиотека статическая, либо динамическая.
+ Все задачи, где применяются массивы или структуры данных, должны быть реализованы с использованием функций управления памятью.
+ Массивы и структуры данных должны инициализироваться либо из файла, либо случайным образом. Ввод значений массива с клавиатуры запрещен.
+ Любые параметры программы должны вводиться через командную строку с последующей их валидацией. В случае правильного результата вывести "help"-строку (описание программы и параметров, которые принимает) и вернуть 1 (EXIT_FAILURE).

## Варианты

1. Пусть есть структура данных ***двунаправленная очередь (deque)***, размер которой ограничен числом *N*. Реализовать потокобезопасную двунаправленную очередь с соответствующими функциями (add / addLast, remove / removeFirst, peek / peekFirst, etc.).
2. Пусть есть структура данных ***очередь с приоритетами (priority_queue)*** такая, что элементы в ней упорядочены **натуральным образом** (по факту, задан некоторый способ упорядочения структуры данных). Реализовать потокобезопасную очередь с приоритетами с cоответствующими функциями (add, remove, peek, etc.).
3. Пусть есть структура данных ***стек (stack)***. Реализовать потокобезопасный стек с соответствующими функциями (push, pop, peek, etc.).
4. Пусть есть структура данных ***хеш-таблица (hash_map)***. Реализовать потокобезопасную хеш-таблицу с соответствующими функциями (put, get, remove, etc.). Хеш-функция может быть выбрана любой.
5. Пусть есть $N_{acc}$ банковских аккаунтов ($N_{threads} \leq N_{acc}$) вида:

   ```c
   struct bank_account{
        char* fullname;
        float balance;
   }
   ```

   В некоторый случайный момент времени $t_n$ поток берет и переводит какую-то сумму с банковского аккаунта на случайный другой. Реализовать программу, эмулирующую работу банка со следующими условиями:
   1. Программа не должна допускать взаимной блокировки потоков.
   2. Информация о переводах с одного аккаунта на другой должна быть выведены на stdout.
   3. Общая сумма денег на всех аккаунтах не должна изменяться со временем и должна выводится с некоторой регулярностью.
   4. Баланс на банковском аккаунте не должен быть отрицательным.
   5. Длительность перерыва между переводами сделать рандомным, но относительно небольшим.
   6. Время работы ограничить 1 минутой.

6. Реализовать параллельную программу, которая решает судоку для сетки N x N (9x9 или 16x16).
7. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать параллельные функции:
    + Поиска в глубину графа (Depth-First Search).
    + Поиска в ширину графа (Breadth-First Search).
    + Определения наличия цикла в графе.

8. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать параллельный алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа ко всем остальным. Вывести пути и их длины для некоторой начальной вершины и всех остальных.

9. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Пусть граф является звездообразным (все вершины связаны с центральной). Реализовать паралелльный алгоритм поиска центра звезды.

10. Дана структура, описывающая **узел графа**:

    ```c
    struct graph_node{
        int value;
        struct graph_node** edges;
        int edges_count;
    }
    ```

    Реализовать параллельный алгоритм, который проверяет существует ли некоторый путь из одной вершины графа в другую. Если таких путей несколько, вывести наиболее длинный.
