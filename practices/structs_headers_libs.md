# Структуры, заголовочные файлы, инструменты сборки

## Содержание

+ [Структуры, объединения, typedef](structs_headers_libs.md#Структуры-объединения-typedef)
+ [Заголовочные файлы: взгляд внутрь](structs_headers_libs.md#Заголовочные-файлы-взгляд-внутрь)
+ [Библиотеки: статические и динамические](structs_headers_libs.md#Библиотеки-статические-и-динамические)
+ [Продвинутая компиляция: Make и CMake](structs_headers_libs.md#Продвинутая-компиляция-Make-и-CMake)
+ [.clang-format](structs_headers_libs.md#clang-format)

## Структуры, объединения, typedef

**Структура** - это совокупность нескольких переменных, часто различных типов, сгруппированных под единым именем для удобства обращения. С их помощью можно организовывать сложные данные и рассматривать их как единое целое, а также реализовывать многие известные структуры данных такие, как списки (односвязные, двусвязные), бинарные деревья, и т.д.

Структуры объявляются с помощью ключевого слова ```struct```, например:

```c
struct point {
    int x;
    int y;
};
```

Объявление переменной типа структуры осуществляется также через ключевое слово:

```c
struct point pt;
```

Структуру можно инициализировать путем передачи списка значений констант или вызова функции, возвращающей структуру соответствующего типа:

```c
struct point min_pt = {0, 0};
struct point max_pt = get_max_pt();
```

Обращение к полям переменной типа структуры осуществляется следующим образом (*имя-структуры.поле*):

```c
min_pt.x
```

Структуру можно передавать в качестве параметра и/или возвращаемого значения функции:

```c
struct point get_max_pt(){
    // get size of the screen
    // that is detected by system

    struct point max_pt;

    max_pt.x = x;
    max_pt.y = y;
    return max_pt;
};
```

Также структуры могут хранится в массивах и инициализировать через фигурные скобки:

```c
struct key {
    char* word;
    int count;
} keytab[] = {
    "auto", 0,
    "break", 0,
    "case", 0,
    "char", 0,
    "const", 0,
    "continue", 0,
    "default", 0,
    "unsigned", 0,
    "void", 0,
    "volatile", 0,
    "while", 0
};
```

Структура может содержать в себе другие структуры:

```c
struct rectangle {
    struct point min_pt;
    struct point max_pt;
}
```

Пусть есть переменная ```struct rect screen```, тогда обращение к такой структуре будет аналогично предыдущим случаям:

```c
screen.max_pt.x
```

Также структура может хранить в себе указатели, в частности, указатели того же типа структуры. Например, для узла односвязного списка:

```c
struct list_node{
    int value;
    struct list_node *next;
}
```

Если переменная обьявлена как указатель на структуру, то обращение к полям такой структуры осуществляется следующим образом (*имя-структуры->поле* или **указатель.поле*):

```c
node.next->value
```

**Объединение (union)** - переменная, которая может содержать объекты различного типа и размеров (но не одновременно); при этом удовлетворение требований к размеру и выравниванию возлагается на компилятор. С помощью объединений можно работать с различными типами данных в пределах одного блока памяти. Синтаксис выглядит следующим образом:

```c
union student_union{
    char name[20];
    int course;
    double marks_average;
};
```

Фактически, объединение является структурой, хранящяяся в одном блоке памяти, сама она имеет достаточную длину, чтобы хранить самый длинный элемент.

В языке Си есть специальное средство, которое позволяет определять имена для новых типов данных - оператор ```typedef```:

```c
typedef struct student Student_s;
typedef union student_union Student_u;
typedef struct list_node{
    int value;
    struct list_node *next;
} ListNode;
```

Это позволяет создавать псевдонимы в коде, делая его более понятным и информативным для чтения (даже самодокументируемым). Оператор похож на директиву ```#define``` с тем исключением, что директива анализируется препроцессором, а оператор компилятором, делая возможным, например, такое объявление (объявление *указателя на функцию* двух аргументов типа char\*, возвращающую значение int):

```c
typedef int (*PFI) (char*, char*);
```

[К оглавлению](structs_headers_libs.md#структуры-заголовочные-файлы-инструменты-сборки)

## Заголовочные файлы: взгляд внутрь

До сих пор программы рассматривались как один файл с исходным кодом: функциями и директивами, подключением библиотек и т.п. Но с ростом объемов кода возникает необходимость делить программу на составные части, т.е. на несколько файлов.

В общем случае, структура проекта на C/C++ выглядит следующим образом:

```project
./                   Config files (Makefile, CMakeLists.txt, etc.)
./src                Source files
./include            Header files that expose the public interface and are to be installed
./lib                Compiled libraries (static and dynamic)
./bin | ./build      Compiled binaries
```

Пусть есть несколько функций, которые реализуют стек (*push, pop* и т.д.), и мы разнесли их в разные файлы. Чтобы сделать доступными объявления функций, константы, обычно общедоступный материал помещают в **заголовочный файл (header)**, который имеет расширение *.h*, который подключается к файлам по мере необходимости. Такой подход позволяет реализовывать программые компоненты независимо друг от друга, при этом программные зависимости будут сводится только к необходимости знания контракта фукнции в каждом компоненте.

Всего бывают 2 типа заголовочных файлов:

1. **Стандартные**: они содержат определеления библиотек из стандарта языка Си ANSI/ISO и хранятся в каталоге компилятора и доступны в любом компиляторе. Всего таких файлов в языке 31, в таблице приведены некоторые наиболее часто используемые заголовочные файлы:

    |Заголовочный файл | Описание |
    | ---- | ---- |
    | <assert.h> | Диагностика программ и помощь в дебаггинге программ|
    | <errno.h> | Отлавливание ошибок и их обработка |
    | <float.h> | Определенные в конкретной ОС константы чисел с плавающей точкой (экспонента, и т.п.) |
    | <math.h> | Математические операции и функции (sin, cos, log2, pow, и т.д.), при компиляции требуется добавлять флаг *-lm* |
    | <stdio.h> | Ввод и вывод |
    | <string.h> | Манипуляции над строками |
    | <time.h> | Работа со временем и датами |
    | <locale.h> | Локализация программ (изменение языка и дат) |

2. **Пользовательские/нестандартные**: файлы, не являющиеся частью стандарта языка, или пользовательские файлы. Чаще всего это либо сторонние библиотеки, которые инсталлируются в систему и\или доступны конкретной версии компилятора.

Подключение заголовочных файлов выполняется через директиву ```#include``` через следующий синтаскис:

```c
#include <filename.h>   
#include "filename.h"    
```

Форма записи здесь зависит от того, является ли файл частью стандартной библиотеки (```<filename.h>```) или является сторонним файлом (через двойные кавычки). В первом случае компилятор ищет файлы в системных каталогах компилятора, во втором случае компилятор рассматривает строку как относительный путь к файлу и будет искать в файл в указанном каталоге или в том же каталоге, где расположен исходный файл.

При определении своих заголовочных файлов важно помнить, что **каждая** директива *#include* будет означать подключение всех данных из целевого файла в программу, что при разбиении программы на составные компоненты в различных файлах будет приводить к повторному чтению данных каждый раз, когда один и тот же файл указывается в директиве, и, возможно, приводить к ошибкам компиляции или увеличению времени генерации выходного бинарного файла. Чтобы избежать такой ситуации, в языке Си предусмотрены 2 способа контроля - **защита подключения** (использование директив препроцессора для **условной компиляции**) или специальная директива ```#pragma once``` (нестандартная, но хорошо распространенная).

Первый способ основан на использовании директив препроцессора для **условной компиляции**. Выглядит это следующим образом:

```c
#ifndef HEADER_H   
#define HEADER_H

// содержимое 

#endif
```

Данный код определяет **идентификатор макроса** *HEADER_H*, который в данном случае регулирует количество подключений, а также проверяет при подключении на его наличие: однажды определенный макрос не позволяет читать содержимое и компилятор пропускает все что до *#endif*, избегая повторного определения. Но при этом возникают проблемы, когда идентификатор макроса становится неуникальным, поэтому для избежания коллизии (совпадении имен) все идентификаторы должны быть уникальными.

Второй способ - это всего-навсего добавление в начало заголовочного файла директивы ```#pragma once```. Вот как это выглядит:

```c
#pragma once

// содержимое 
```

Такой метод борьбы с повторным подключением увеличит в большинстве скорость компиляции из-за его высокоуровневости и позволит избежать необходимости определения идентификаторов макросов и соответсвтующих коллизий, но также приведет к тому, что программист **вынужден** полагаться на компилятор в проверке. Изначально директива не является частью стандартного набора директив, но сейчас большинство компиляторов поддерживают данный механизм.

Для написания переносимового кода можно комбинировать данные команды, что дает преимущество при создании кода под разные компиляторы.

[К оглавлению](structs_headers_libs.md#структуры-заголовочные-файлы-инструменты-сборки)

## Библиотеки: статические и динамические

С ростом количества кода проекта рано или поздно возникает необходимость разбиения кода на отдельные компоненты. В этом случае код выносится в отдельные файлы, компилируется и сохраняется в виде **библиотеки** - файла, содержащего набор объектных файлов (*.o*), которые могут быть связаны с другими программами.

**Статическая библиотека** - это файл, содержащий набор объектных файлов (*.o*), которые могут быть связаны с другими программами. Такие библиотеки имеют расширение *.a* (архив) в Unix-подобных системах и *.lib* в Windows. При компиляции программы, использующей статическую библиотеку, все необходимые объектные файлы из библиотеки копируются в исполняемый файл, что увеличивает его размер, но делает программу независимой от внешних библиотек во время выполнения.

Чтобы создать статическую библиотеку, нужно сначала скомпилировать исходные файлы в объектные файлы с помощью флага *-c*, а затем использовать утилиту *ar* для создания архива:

```bash
gcc -c file1.c file2.c -o mylib.o
ar rcs libmylib.a mylib.o
```

Теперь, чтобы использовать эту библиотеку в своей программе, нужно указать компилятору путь к библиотеке и имя библиотеки при компиляции:

```bash
gcc main.c -L. -lmylib -o myprogram
```

**Динамическая библиотека** (или разделяемая библиотека) - это файл, содержащий код и данные, которые могут быть загружены и использованы программой во время выполнения. Такие библиотеки имеют расширение *.so* (shared object) в Unix-подобных системах и *.dll* (dynamic link library) в Windows. При использовании динамической библиотеки, программа не включает код библиотеки в свой исполняемый файл, что уменьшает его размер и позволяет нескольким программам использовать одну и ту же библиотеку одновременно, однако, при выполнении программа должна знать, где найти эту библиотеку.

Чтобы создать динамическую библиотеку, нужно скомпилировать исходные файлы с флагом *-fPIC* (Position Independent Code) и затем использовать флаг *-shared* для создания разделяемой библиотеки:

```bash
gcc -fPIC -c file1.c file2.c -o mylib.o
gcc -shared -o mylib.so mylib.o
```

Чтобы использовать динамическую библиотеку в своей программе, нужно указать компилятору путь к библиотеке и имя библиотеки при компиляции:

```bash
gcc main.c -L. -lmylib -o myprogram
```

Во время выполнения программы, если динамическая библиотека не находится в стандартных путях поиска, нужно указать путь к библиотеке с помощью переменной окружения *LD_LIBRARY_PATH* в Unix-подобных системах или *PATH* в Windows:

```bash
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
./myprogram
```

Пример программы с раздельными компонентами, связанными через заголовочный файл представлен [здесь](../code/lib).

[К оглавлению](structs_headers_libs.md#структуры-заголовочные-файлы-инструменты-сборки)

## Продвинутая компиляция: Make и CMake

В предыдущих примерах компиляция и сборка программ выполнялась с помощью простых команд *gcc*. Однако, в реальных проектах, особенно когда проект состоит из множества файлов и библиотек, управление процессом сборки становится сложной задачей. Для этого используются инструменты автоматизации сборки, такие как **Make** и **CMake**.

### Make

**[Make](https://www.gnu.org/software/make/)** - это инструмент, который автоматизирует процесс сборки программ, созданный еще в 1976 году. Он использует файл с именем *Makefile*, в котором описываются правила сборки, зависимости между файлами и команды для компиляции и связывания. Пример простого *Makefile*:

```makefile
# Компилятор
CC = gcc
# Флаги компиляции
CFLAGS = -Wall -g
# Целевой файл
TARGET = myprogram
# Исходные файлы
SRCS = $(wildcard *.c)
# Объектные файлы
OBJS = $(SRCS:.c=.o)
# Правило по умолчанию
all: $(TARGET)
# Правило для сборки целевого файла
$(TARGET): $(OBJS)
    $(CC) $(CFLAGS) -o $@ $^
# Правило для компиляции исходных файлов в объектные файлы
%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@
# Правило для очистки сгенерированных файлов
clean:
    rm -f $(OBJS) $(TARGET)
```

Чтобы собрать программу, достаточно выполнить команду *make* в терминале:

```bash
make
```

Несмотря на свою простоту, Make достаточно сложен в использовании для больших проектов, особенно когда требуется поддержка кросс-платформенной сборки или интеграции с другими инструментами. Поэтому в таких случаях часто используется CMake.

### CMake

**[CMake](https://cmake.org/cmake/help/latest/)** - это более современный и мощный инструмент для управления сборкой, который позволяет создавать кросс-платформенные проекты. CMake использует файл с именем *CMakeLists.txt*, в котором описываются цели сборки, зависимости и настройки проекта. Пример простого *CMakeLists.txt*:

```cmake
# Минимальная версия CMake
cmake_minimum_required(VERSION 3.10)
# Название проекта
project(MyProject)

# Установка флагов компиляции, используемых CMake
# В данном случае устанавливается стандарт C99
set(CMAKE_C_STANDARD 99)

# Поиск всех исходных файлов с расширением .c в текущем каталоге
file(GLOB SOURCES "*.c")

# Создание исполняемого файла из найденных исходных файлов
add_executable(myprogram ${SOURCES})
```

[К оглавлению](structs_headers_libs.md#структуры-заголовочные-файлы-инструменты-сборки)

## .clang-format

Для форматирования кода в соответствии с определенными стилями используется инструмент **[clang-format](https://clang.llvm.org/docs/ClangFormat.html)**, который является частью проекта LLVM. Он позволяет автоматически форматировать исходный код на C, C++, Java, JavaScript, Objective-C, Protobuf и других языках.

Установка clang-format достаточно проста. Напрмимер, в Ubuntu:

```bash
sudo apt-get install clang-format
```

После установки, можно создать файл конфигурации `.clang-format` в корневом каталоге проекта. Пример простого файла конфигурации:

```yaml
# Style that clang-format will use
BasedOnStyle: Google
# Spaces amount for each indentation level
IndentWidth: 4
# Maximum allowed line length
ColumnLimit: 100
# Use spaces instead of tabs
UseTab: Never
# Place the opening brace of a function on the same line as the function declaration
BraceWrapping:
  AfterFunction: false
```

Clang-format можно использовать из командной строки для форматирования отдельных файлов или всех файлов в проекте. Например, чтобы отформатировать файл `main.c`, можно выполнить следующую команду:

```bash
clang-format -i main.c
```

Флаг `-i` указывает на то, что изменения будут внесены непосредственно в файл. Если нужно отформатировать все файлы в проекте, можно использовать следующую команду, которая найдет все файлы с расширением `.c` и `.h` и отформатирует их:

```bash
clang-format -i $(find . -name "*.c" -o -name "*.h") 
```

[К оглавлению](structs_headers_libs.md#структуры-заголовочные-файлы-инструменты-сборки)
